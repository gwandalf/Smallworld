//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil
//     Les modifications apportées à ce fichier seront perdues si le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Implementation.Modele.Jeu
{
	using Interfaces.Modele.Jeu;
    using Interfaces.Modele.Jeu.Unit;
    using Implementation.Modele.Jeu.Unit;
	using Implementation.Modele.Creation;
	using System;
    using System.Collections;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
    using Wrapper;
    using Interfaces.Vue;
    using Implementation.Vue;
    using System.ComponentModel;
    using System.IO;
    using System.Xml;
    using System.Xml.Serialization;
   
    [Serializable]
	public class CarteCS : CarteI
	{
        //wrapper with dll library
        private CarteWrapper carteW;
        [XmlIgnoreAttribute]
        public CarteWrapper CarteW
        {
            get { return carteW; }
            set { carteW = value; }
        }

        //representation of the types of the cases by numbers
        private List<List<int>> codeCases;
        public List<List<int>> CodeCases
        {
            get { return codeCases; }
            set { codeCases = value; }
        }

        //dimension of the map
        private int dim;
        public int Dim
        {
            get { return dim; }
            set { dim = value; }
        }

        //fly-wheight factory of the cases
		private FabriqueCaseI fabrique;
        [XmlIgnoreAttribute]
        public FabriqueCaseI Fabrique
		{
            get { return fabrique; }
            set { fabrique = value; }
		}

        //cases, seen as "real" cases (not numbers)
        private List<List<CaseI>> cases;
        [XmlIgnoreAttribute]
        public List<List<CaseI>> Cases
        {
            get { return cases; }
        }

        //unit currently selected
        private UniteI selected;
        [XmlIgnoreAttribute]
        public UniteI Selected
        {
            get { return selected; }
            set { selected = value; }
        }

        //legions placed on the map
        private List<LegionI> legions;
        [XmlIgnoreAttribute]
        public List<LegionI> Legions
        {
            get { return legions; }
            set { legions = value; }
        }

        //Temporary legion added recently which is to be shown
        private LegionI tmpLegion;
        [XmlIgnoreAttribute]
        public LegionI TmpLegion
        {
            get { return tmpLegion; }
        }

        public event PropertyChangedEventHandler PropertyChanged;
        private void OnPropertyChanged(string name)
        {
            if(PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(name));
        }

        public CarteCS()
        {
            legions = new List<LegionI>();
            fabrique = new FabriqueCase();
        }

        /**
         * \fn public Carte(int dim, List(JoueurI) joueurs)
         * \brief "Carte" constructor, placing players. Use CarteWrapper.
         * 
         * the C++ map is initialized.
         * Then, the hashtable is filled and the The current map is associated to each unite
         * Then, the "real" cases are set
         * 
         * param[in] dim : dimension of the map
         * param[in, out] joueurs : list of the players.
         * 
         */
		public CarteCS(int dim, List<Joueur> joueurs)
		{
            //construction carteWrapper
            this.carteW = new CarteWrapper(dim, joueurs[0].NbMaxUnites);
            this.dim = dim;
            legions = new List<LegionI>();
            int[] loc = { 0, dim - 1};

            //cases initilization
            fabrique = new FabriqueCase();
            cases = new List<List<CaseI>>(this.Dim);
            codeCases = new List<List<int>>(this.Dim);
            for (int j = 0; j < this.Dim; j++)
            {
                cases.Add(new List<CaseI>(this.Dim));
                codeCases.Add(new List<int>(this.Dim));
                for (int k = 0; k < this.Dim; k++)
                {
                    codeCases[j].Add(carteW.getCases(j, k));
                    switch (carteW.getCases(j, k))
                    {
                        case 0:
                            cases[j].Add(fabrique.Desert);
                            break;
                        case 1:
                            cases[j].Add(fabrique.Plaine);
                            break;
                        case 2:
                            cases[j].Add(fabrique.Foret);
                            break;
                        case 3:
                            cases[j].Add(fabrique.Montagne);
                            break;
                        case 4:
                            cases[j].Add(fabrique.Eau);
                            break;
                        default: break;
                    }
                }
            }

            //units placement
            int i = 0;
            foreach (Joueur j in joueurs)
            {
                foreach (UniteI u in j.Unites)
                {
                    u.Carte = this;
                    u.setBonusMalusPoints(true);
                    u.placeOnMap(carteW.getPlace(i, 0), carteW.getPlace(i, 1));
                    u.setBonusMalusPoints(false);
                }
                i++;
            }
            
		}

        void generateCases(int nbTypes) 
        { 
            this.carteW.generateCases(nbTypes); 
        }

        /// <summary>
        /// the method give a list of all the positions which are ajacents to a unit
        /// </summary>
        /// <param name="unite"> unit of which the ajacent cases are to be given </param>
        /// <returns> list of all the adjacents positions </returns>
		public virtual List<Tuple<int, int>> getListeAdjacents(UniteI unite)
		{
            //we define the values to add
            List<Tuple<int, int>> adders = new List<Tuple<int, int>>(4);
            adders.Add(new Tuple<int, int>(1, 0));
            adders.Add(new Tuple<int, int>(0, 1));
            adders.Add(new Tuple<int, int>(-1, 0));
            adders.Add(new Tuple<int, int>(0, -1));

            //we add successively the possible position only if they are not out of the map
            List<Tuple<int, int>> res = new List<Tuple<int, int>>();
            for (int i = 0; i < adders.Count; i++)
            {
                Tuple<int, int> t = new Tuple<int, int>(unite.Legion.Ligne + adders[i].Item1, unite.Legion.Colonne + adders[i].Item2);
                if (t.Item1 < Dim && t.Item2 < Dim && t.Item1 >= 0 && t.Item2 >= 0)
                    res.Add(t);
            }
            return res;
		}

		public virtual void deplacer(UniteI unite, int lig, int col)
		{
             unite.deplacer(lig, col);
		}

        /// <summary>
        /// find out if a case is empty
        /// </summary>
        /// <param name="lig"> line of the case </param>
        /// <param name="col"> column of the case </param>
        /// <returns> true if there aren't legions at the given position, else returns false </returns>
		public virtual bool isEmpty(int lig, int col)
		{
            bool res = true;
            foreach (LegionI l in legions)
            {
                // if at least one legion is at the given position, the predicates fails
                if (l.Ligne == lig && l.Colonne == col)
                {
                    res = false;
                    break;
                }
            }
            return res;
		}

        public VueCaseI makeView(int l, int c)
        {
            return new VueCase(this, l, c);
        }

        /// <summary>
        /// we look for an existing legion at the specified case
        /// </summary>
        /// <param name="lig"> line </param>
        /// <param name="col"> column </param>
        /// <returns> a pointer to the legion if found, else null </returns>
        public LegionI getLegion(int lig, int col)
        {
            LegionI res = null;
            //we look for an existing legion at the specified case
            foreach (LegionI l in legions)
            {
                if (l.Ligne == lig && l.Colonne == col)
                {
                    res = l;
                    break;
                }
            }
            return res;
        }

        /// <summary>
        /// add a legion to the list
        /// </summary>
        /// <param name="legion"> legion to add </param>
        public void ajouterLegion(LegionI legion)
        {
            legions.Add(legion);
            tmpLegion = legion;
            OnPropertyChanged("Legion");
        }

        /// <summary>
        /// association of the cases to the respective numbers
        /// usefull for the loading of a saved game
        /// </summary>
        public void generateCases()
        {
            cases = new List<List<CaseI>>(this.Dim);
            for (int j = 0; j < this.Dim; j++)
            {
                cases.Add(new List<CaseI>(this.Dim));
                for (int k = 0; k < this.Dim; k++)
                {
                    switch (codeCases[j][k])
                    {
                        case 0:
                            cases[j].Add(fabrique.Desert);
                            break;
                        case 1:
                            cases[j].Add(fabrique.Plaine);
                            break;
                        case 2:
                            cases[j].Add(fabrique.Foret);
                            break;
                        case 3:
                            cases[j].Add(fabrique.Montagne);
                            break;
                        case 4:
                            cases[j].Add(fabrique.Eau);
                            break;
                        default: break;
                    }
                }
            } 
        }

        /// <summary>
        /// make the unsaved links (used by the saver)
        /// </summary>
        /// <param name="joueurs"> players of the game </param>
        public void linkJoueurs(List<Joueur> joueurs)
        {
            int i = 0;
            foreach (Joueur j in joueurs)
            {
                j.Points = 0;
                foreach (UniteI u in j.Unites)
                {
                    u.Carte = this;
                    u.Joueur = j;
                    u.Automate.Unite = u;
                    u.setBonusMalusPoints(true);
                    int l = u.Legion.Ligne;
                    int c = u.Legion.Colonne;
                    u.Legion = null;
                    u.placeOnMap(l, c);
                    u.setBonusMalusPoints(false);
                }
                i++;
            }
        }

        public void initLegions()
        {
            legions = new List<LegionI>();

        }

        //suggest the specified case
        public void suggerer(int x, int y)
        {
            OnPropertyChanged("" + x + ";" + y);
        }

	}
}

